package main

import (
	"encoding/json"
	"fmt"
	"syscall/js"
)

const (
	isWasm bool = true
)

var game *Game

func main() {
	fmt.Println("WebAssembly loaded!")

	setGlobals()
	setGameAPI()

    <-make(chan bool)
}

func setGlobals() {
	js.Global().Set("frameMillis", frameMillis)

	js.Global().Set("pingType", pingType)
	js.Global().Set("candidateType", candidateType)
	js.Global().Set("offerType", offerType)
	js.Global().Set("answerType", answerType)
	js.Global().Set("voiceCandidateType", voiceCandidateType)

	js.Global().Set("voiceOfferType", voiceOfferType)
	js.Global().Set("voiceAnswerType", voiceAnswerType)
	js.Global().Set("initType", initType)
	js.Global().Set("joinType", joinType)
	js.Global().Set("leftType", leftType)

	js.Global().Set("initVoiceType", initVoiceType)
	js.Global().Set("joinVoiceType", joinVoiceType)
	js.Global().Set("leftVoiceType", leftVoiceType)
	js.Global().Set("chatType", chatType)
	js.Global().Set("keyType", keyType)

	js.Global().Set("gameStateType", gameStateType)
	js.Global().Set("playerInitType", playerInitType)
	js.Global().Set("levelInitType", levelInitType)
	js.Global().Set("objectInitType", objectInitType)

	js.Global().Set("upKey", upKey)
	js.Global().Set("downKey", downKey)
	js.Global().Set("leftKey", leftKey)
	js.Global().Set("rightKey", rightKey)
	js.Global().Set("dashKey", dashKey)
	js.Global().Set("mouseClick", mouseClick)
	js.Global().Set("altMouseClick", altMouseClick)
}

func setGameAPI() {
	game = newGame()
	js.Global().Set("wasmAddPlayer", AddPlayer(game))
	js.Global().Set("wasmAddObject", AddObject(game))
	js.Global().Set("wasmSetPlayerData", SetPlayerData(game))
	js.Global().Set("wasmSetObjectData", SetObjectData(game))
	js.Global().Set("wasmHas", Has(game))
	js.Global().Set("wasmDelete", Delete(game))
	js.Global().Set("wasmLoadLevel", LoadLevel(game))
	js.Global().Set("wasmUpdateState", UpdateState(game))
}

func AddPlayer(g *Game) js.Func {  
    return js.FuncOf(func(this js.Value, args []js.Value) interface{} {
		if len(args) != 2 {
			fmt.Println("Expected 2 argument(s), got ", len(args))
			return nil
		}

		id := args[0].Int()
		pos := args[1].Get("Pos")
		dim := args[1].Get("Dim")

		initData := NewPlayerInitData(id, parseVec2(pos), parseVec2(dim))
		g.addPlayer(initData)
		return nil
    })
}

func AddObject(g *Game) js.Func {  
    return js.FuncOf(func(this js.Value, args []js.Value) interface{} {
		if len(args) != 2 {
			fmt.Println("Expected 2 argument(s), got ", len(args))
			return nil
		}

		id := args[0].Int()
		pos := args[1].Get("Pos")
		dim := args[1].Get("Dim")

		initData := NewObjectInitData(Init { Id: id, Pos: parseVec2(pos), Dim: parseVec2(dim) })
		g.addObject(initData)
		return nil
    })
}

func SetPlayerData(g *Game) js.Func {  
    return js.FuncOf(func(this js.Value, args []js.Value) interface{} {
		if len(args) != 2 {
			fmt.Println("Expected 2 argument(s), got ", len(args))
			return nil
		}

		id := args[0].Int()
		pos := args[1].Get("Pos")
		vel := args[1].Get("Vel")
		evel := args[1].Get("EVel")
		acc := args[1].Get("Acc")
		dir := args[1].Get("Dir")

		if !g.has(Id(playerIdSpace, id)) {
			fmt.Println("Player does not exist: ", id)
			return nil
		}

		pData := PlayerData {
			Pos: parseVec2(pos),
			Vel: parseVec2(vel),
			EVel: parseVec2(evel),
			Acc: parseVec2(acc),
			Dir: parseVec2(dir),
		}
		g.setPlayerData(id, pData)
		return nil
    })
}

func SetObjectData(g *Game) js.Func {  
    return js.FuncOf(func(this js.Value, args []js.Value) interface{} {
		if len(args) != 2 {
			fmt.Println("Expected 2 argument(s), got ", len(args))
			return nil
		}

		id := args[0].Int()
		pos := args[1].Get("Pos")
		vel := args[1].Get("Vel")

		if !g.has(Id(objectIdSpace, id)) {
			fmt.Println("Object does not exist: ", id)
			return nil
		}

		oData := ObjectData {
			Pos: parseVec2(pos),
			Vel: parseVec2(vel),
		}
		g.setObjectData(id, oData)
		return nil
    })
}


func Has(g *Game) js.Func {  
    return js.FuncOf(func(this js.Value, args []js.Value) interface{} {
		if len(args) != 2 {
			fmt.Println("Expected 2 argument(s), got ", len(args))
			return nil
		}

		space := args[0].Int()
		id := args[1].Int()
		return g.has(Id(space, id))
    })
}

func Delete(g *Game) js.Func {  
    return js.FuncOf(func(this js.Value, args []js.Value) interface{} {
		if len(args) != 2 {
			fmt.Println("Expected 2 argument(s), got ", len(args))
			return nil
		}

		space := args[0].Int()
		id := args[1].Int()
		g.delete(Id(space, id))
		return nil
    })
}

func LoadLevel(g *Game) js.Func {  
    return js.FuncOf(func(this js.Value, args []js.Value) interface{} {
		if len(args) != 1 {
			fmt.Println("Expected 1 argument(s), got ", len(args))
			return nil
		}

		level := args[0].Int()
		g.loadLevel(level)

		objects := g.createObjectInitMsg()
		b, err := json.Marshal(objects)
		if err != nil {
			fmt.Println("wasmLoadLevel: ", err)
			fmt.Println("objects: ", objects)
		}
		return string(b)
	})
}

func UpdateState(g *Game) js.Func {  
    return js.FuncOf(func(this js.Value, args []js.Value) interface{} {
		g.updateState()
		state := g.createGameStateMsg()
		b, err := json.Marshal(state)
		if err != nil {
			fmt.Println("wasmUpdateState: ", err)
			fmt.Println("state: ", state)
		}
		return string(b)
    })
}

func parseVec2(vec js.Value) Vec2 {
	return NewVec2(vec.Get("X").Float(), vec.Get("Y").Float())
}