package main

import (
	"encoding/json"
	"fmt"
	"strconv"
	"strings"
	"syscall/js"
)

const (
	isWasm bool = true
)

var game *Game

func main() {
	fmt.Println("WebAssembly loaded!")

	setGlobals()
	setGameAPI()

    <-make(chan bool)
}

func setGlobals() {
	js.Global().Set("frameMillis", frameMillis)
	js.Global().Set("debugMode", debugMode)

	js.Global().Set("pingType", int(pingType))
	js.Global().Set("candidateType", int(candidateType))
	js.Global().Set("offerType", int(offerType))
	js.Global().Set("answerType", int(answerType))
	js.Global().Set("voiceCandidateType", int(voiceCandidateType))

	js.Global().Set("voiceOfferType", int(voiceOfferType))
	js.Global().Set("voiceAnswerType", int(voiceAnswerType))
	js.Global().Set("initType", int(initType))
	js.Global().Set("joinType", int(joinType))
	js.Global().Set("leftType", int(leftType))

	js.Global().Set("initVoiceType", int(initVoiceType))
	js.Global().Set("joinVoiceType", int(joinVoiceType))
	js.Global().Set("leftVoiceType", int(leftVoiceType))
	js.Global().Set("chatType", int(chatType))
	js.Global().Set("keyType", int(keyType))

	js.Global().Set("objectDataType", int(objectDataType))
	js.Global().Set("objectUpdateType", int(objectUpdateType))
	js.Global().Set("playerInitType", int(playerInitType))
	js.Global().Set("levelInitType", int(levelInitType))

	js.Global().Set("playerSpace", int(playerSpace))
	js.Global().Set("wallSpace", int(wallSpace))
	js.Global().Set("bombSpace", int(bombSpace))
	js.Global().Set("boltSpace", int(boltSpace))
	js.Global().Set("rocketSpace", int(rocketSpace))
	js.Global().Set("paperStarSpace", int(paperStarSpace))
	js.Global().Set("explosionSpace", int(explosionSpace))
	js.Global().Set("pickupSpace", int(pickupSpace))

	js.Global().Set("uziWeapon", int(uziWeapon))
	js.Global().Set("bazookaWeapon", int(bazookaWeapon))

	js.Global().Set("objectStatesProp", int(objectStatesProp))
	js.Global().Set("initializedProp", int(initializedProp))
	js.Global().Set("deletedProp", int(deletedProp))

	js.Global().Set("attributesProp", int(attributesProp))
	js.Global().Set("dimProp", int(dimProp))
	js.Global().Set("posProp", int(posProp))
	js.Global().Set("velProp", int(velProp))
	js.Global().Set("extVelProp", int(extVelProp))
	js.Global().Set("accProp", int(accProp))
	js.Global().Set("jerkProp", int(jerkProp))
	js.Global().Set("dirProp", int(dirProp))
	js.Global().Set("equipTypeProp", int(equipTypeProp))
	js.Global().Set("equipDirProp", int(equipDirProp))

	js.Global().Set("keysProp", int(keysProp))
	js.Global().Set("healthProp", int(healthProp))

	js.Global().Set("ownerProp", int(ownerProp))
	js.Global().Set("targetProp", int(targetProp))
	js.Global().Set("hitsProp", int(hitsProp))
	js.Global().Set("killProp", int(killProp))
	js.Global().Set("deathProp", int(deathProp))

	js.Global().Set("profileDimProp", int(profileDimProp))
	js.Global().Set("profilePosProp", int(profilePosProp))
	js.Global().Set("profilePointsProp", int(profilePointsProp))

	js.Global().Set("stairAttribute", int(stairAttribute))
	js.Global().Set("platformAttribute", int(platformAttribute))
	js.Global().Set("groundedAttribute", int(groundedAttribute))
	js.Global().Set("solidAttribute", int(solidAttribute))
	js.Global().Set("attachedAttribute", int(attachedAttribute))

	js.Global().Set("upKey", int(upKey))
	js.Global().Set("downKey", int(downKey))
	js.Global().Set("leftKey", int(leftKey))
	js.Global().Set("rightKey", int(rightKey))
	js.Global().Set("dashKey", int(dashKey))
	js.Global().Set("interactKey", int(interactKey))
	js.Global().Set("mouseClick", int(mouseClick))
	js.Global().Set("altMouseClick", int(altMouseClick))
}

func setGameAPI() {
	game = newGame()
	js.Global().Set("wasmAdd", Add(game))
	js.Global().Set("wasmHas", Has(game))
	js.Global().Set("wasmDelete", Delete(game))
	js.Global().Set("wasmUpdateKeys", UpdateKeys(game))
	js.Global().Set("wasmGetData", GetData(game))
	js.Global().Set("wasmSetData", SetData(game))
	js.Global().Set("wasmLoadLevel", LoadLevel(game))
	js.Global().Set("wasmUpdateState", UpdateState(game))
}

func Add(g *Game) js.Func {  
    return js.FuncOf(func(this js.Value, args []js.Value) interface{} {
		if len(args) != 3 {
			fmt.Println("Add: Expected 3 argument(s), got ", len(args))
			return nil
		}

		space := SpaceType(args[0].Int())
		id := IdType(args[1].Int())
		init := NewInit(Id(space, id))
		data := getData(args[2])

		object := g.add(init)

		if object != nil {
			object.SetData(data)
		}
		return nil
    })
}

func Has(g *Game) js.Func {  
    return js.FuncOf(func(this js.Value, args []js.Value) interface{} {
		if len(args) != 2 {
			fmt.Println("Has: Expected 2 argument(s), got ", len(args))
			return nil
		}

		space := SpaceType(args[0].Int())
		id := IdType(args[1].Int())

		return g.has(Id(space, id))
    })
}

func Delete(g *Game) js.Func {  
    return js.FuncOf(func(this js.Value, args []js.Value) interface{} {
		if len(args) != 2 {
			fmt.Println("Delete: Expected 2 argument(s), got ", len(args))
			return nil
		}

		space := SpaceType(args[0].Int())
		id := IdType(args[1].Int())
		g.delete(Id(space, id))

		return nil
    })
}

func UpdateKeys(g *Game) js.Func {  
    return js.FuncOf(func(this js.Value, args []js.Value) interface{} {
		if len(args) != 2 {
			fmt.Println("UpdateKeys: Expected 2 argument(s), got ", len(args))
			return nil
		}

		id := IdType(args[0].Int())
		if !g.has(Id(playerSpace, id)) {
			fmt.Println("UpdateKeys: Player does not exist: ", id)
			return nil
		}

		keyMsg := KeyMsg {
			S: SeqNumType(args[1].Get("S").Int()),
			K: parseKeysAsArray(args[1].Get("K").String()),
			M: parseVec2(args[1].Get("M")),
			D: parseVec2(args[1].Get("D")),
		}

		g.processKeyMsg(id, keyMsg)
		return nil
    })
}

func GetData(g *Game) js.Func {  
    return js.FuncOf(func(this js.Value, args []js.Value) interface{} {
		if len(args) != 2 {
			fmt.Println("GetData: Expected 2 argument(s), got ", len(args))
			return nil
		}

		space := SpaceType(args[0].Int())
		id := IdType(args[1].Int())
		if !g.has(Id(space, id)) {
			fmt.Println("GetData: Object does not exist: ", space, id)
			return nil
		}

		return g.getData(Id(space, id)).Props()
    })
}

func SetData(g *Game) js.Func {  
    return js.FuncOf(func(this js.Value, args []js.Value) interface{} {
		if len(args) != 3 {
			fmt.Println("SetData: Expected 3 argument(s), got ", len(args))
			return nil
		}

		space := SpaceType(args[0].Int())
		id := IdType(args[1].Int())
		if !g.has(Id(space, id)) {
			fmt.Println("SetData: Object does not exist: ", space, id)
			return nil
		}

		data := getData(args[2])
		if (data.Size() == 0) {
			return nil
		}

		g.setData(Id(space, id), data)
		return nil
    })
}

func LoadLevel(g *Game) js.Func {  
    return js.FuncOf(func(this js.Value, args []js.Value) interface{} {
		if len(args) != 1 {
			fmt.Println("LoadLevel: Expected 1 argument(s), got ", len(args))
			return nil
		}

		level := LevelIdType(args[0].Int())
		g.loadLevel(level)

		objects := g.createObjectInitMsg()
		b, err := json.Marshal(objects)
		if err != nil {
			fmt.Println("wasmLoadLevel: ", err)
			fmt.Println("objects: ", objects)
		}
		return string(b)
	})
}

func UpdateState(g *Game) js.Func {  
    return js.FuncOf(func(this js.Value, args []js.Value) interface{} {
		g.updateState()
		state := g.createGameStateMsg()
		b, err := json.Marshal(state)
		if err != nil {
			fmt.Println("wasmUpdateState: ", err)
			fmt.Println("state: ", state)
		}
		return string(b)
    })
}

func getData(data js.Value) Data {
	var prop js.Value
	var err error
	d := NewData()

	prop, err = getPropData(data, initializedProp)
	if err == nil {
		d.Set(initializedProp, prop.Bool())
	}

	prop, err = getPropData(data, deletedProp)
	if err == nil {
		d.Set(deletedProp, prop.Bool())
	}

	prop, err = getPropData(data, attributesProp)
	if err == nil {
		d.Set(attributesProp, parseAttributesAsProp(prop.String()))
	}

	prop, err = getPropData(data, dimProp)
	if err == nil {
		d.Set(dimProp, parseVec2(prop))
	}

	prop, err = getPropData(data, posProp)
	if err == nil {
		d.Set(posProp, parseVec2(prop))
	}

	prop, err = getPropData(data, velProp)
	if err == nil {
		d.Set(velProp, parseVec2(prop))
	}

	prop, err = getPropData(data, extVelProp)
	if err == nil {
		d.Set(extVelProp, parseVec2(prop))
	}

	prop, err = getPropData(data, accProp)
	if err == nil {
		d.Set(accProp, parseVec2(prop))
	}

	prop, err = getPropData(data, jerkProp)
	if err == nil {
		d.Set(jerkProp, parseVec2(prop))
	}

	prop, err = getPropData(data, dirProp)
	if err == nil {
		d.Set(dirProp, parseVec2(prop))
	}

	prop, err = getPropData(data, equipTypeProp)
	if err == nil {
		d.Set(equipTypeProp, prop.Int())
	}

	prop, err = getPropData(data, equipDirProp)
	if err == nil {
		d.Set(equipDirProp, parseVec2(prop))
	}

	prop, err = getPropData(data, keysProp)
	if err == nil {
		d.Set(keysProp, parseKeysAsProp(prop.String()))
	}

	prop, err = getPropData(data, healthProp)
	if err == nil {
		d.Set(healthProp, prop.Int())
	}

	prop, err = getPropData(data, ownerProp)
	if err == nil {
		d.Set(ownerProp, parseSpacedId(prop))
	}

	prop, err = getPropData(data, targetProp)
	if err == nil {
		d.Set(targetProp, parseSpacedId(prop))
	}

	// hitsProp not parsed.

	return d
}

func getPropData(data js.Value, prop Prop) (js.Value, error) {
	stringKey := strconv.Itoa(int(prop))
	propData := data.Get(stringKey)
	if propData.IsNull() || propData.IsNaN() || propData.IsUndefined() {
		return propData, fmt.Errorf("Prop data is missing for %d", prop)
	}
	return propData, nil
}

func parseSpacedId(sid js.Value) SpacedId {
	return Id(SpaceType(sid.Get("S").Int()), IdType(sid.Get("Id").Int()))
}

func parseVec2(vec js.Value) Vec2 {
	return NewVec2(vec.Get("X").Float(), vec.Get("Y").Float())
}

// Key format: "1,3,4"
func parseKeysAsArray(keyStr string) []KeyType {
	keys := make([]KeyType, 0)
	for _, key := range(strings.Split(keyStr, ",")) {
		int, err := strconv.Atoi(key)
		if err != nil {
			continue
		}
		keys = append(keys, KeyType(int))
	}
	return keys
}

// Key format: "1:0,3:1,4:1"
func parseKeysAsProp(keyStr string) map[KeyType]bool {
	keys := make(map[KeyType]bool)
	parsedMap := parseStringMap(keyStr)

	for k, v := range(parsedMap) {
		keys[KeyType(k)] = v
	}
	return keys
}

// Attribute format: "1:0,3:1,4:1"
func parseAttributesAsProp(attributeStr string) map[AttributeType]bool {
	attributes := make(map[AttributeType]bool)
	parsedMap := parseStringMap(attributeStr)

	for k, v := range(parsedMap) {
		attributes[AttributeType(k)] = v
	}
	return attributes
}

func parseStringMap(stringMap string) map[int]bool {
	resultMap := make(map[int]bool)
	for _, entry := range(strings.Split(stringMap, ",")) {
		pair := strings.Split(entry, ":")

		if len(pair) != 2 {
			continue
		}

		key, err := strconv.Atoi(pair[0])
		if err != nil {
			fmt.Println("parseStringMap: ", err)
			continue
		}

		value, err2 := strconv.Atoi(pair[1])
		if err2 != nil {
			fmt.Println("parseStringMap: ", err)
			continue
		}

		if value == 0 {
			resultMap[key] = false 
		} else if value == 1 {
			resultMap[key] = true
		}
	}
	return resultMap
}